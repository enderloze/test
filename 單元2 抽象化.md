# 單元2 抽象化

###### tags: `DS1`, `CYCU`
**目錄：**
[ToC]

## :memo: **Part1 資料抽象化(Data abstraction)**

###  **1-1 物件導向程式設計(Object-Oriented Programing, OOP)**
物件導向程式設計，就是建立所謂"Classes(類別)" of "Objects/Instances(物件)"，其中包含"Attributes(屬性)"和"Behaviors(行為)"。

舉個例子，若我們想要製作的資料結構是車輛規格表，那表格的格式就是"class"，其中的各項規格數據就是"attributes"，而印出、修改等動作則是"behaviors"，最後實際做出來的不同規格表就是"instances"。

而物件導向程式設計有三大概念:
| Encapsulation 封裝 | Inheritance 繼承 | Polymorphism 多形 |
| :---------------: | :--------------: | :---------------------: |
|     隱藏內部資料     |     重複利用     |           靈活變換           |

要注意的是，關於規格說明文件(Operation contract)有以下建議:
1. 在**分析**問題時就開始寫，之後於實際**設計**程式時完成。
2. 要描寫各方法(methods)如何使用，及有何限制。
3. **不要**解說各方法具體上是如何運作的。
4. **不要**描述使用者不能/不該存取的資料，也沒必要。
5. 要定義前置/後置狀態為何。

還有，面對意料之外的狀況時，你可能會有以下反應:
1. 假設永遠不會發生。
2. 無視不符條件的狀況。
3. 回傳標示"出現錯誤"的訊息。
4. ==進行例外應對(Throw an Exception)。==  <- 詳見Part3-4

---

###  **1-2 簡介(Introduction)**
**Q: 為何要進行資料抽象化?**
- 自古以來，程式設計的數個主要問題:
1. 模組性(Modularity)
2. 撰寫風格(Sytle)
3. 可變更性(Modifiability)
4. 使用之方便性(Ease of use)
5. 故障預防(Fail-safe programming)
6. 除錯(Debugging)
7. 測試(Testing)

而關於其中的模組性，有兩個重要概念需要先知道，首先是"Cohesion(內聚)"，指一個模組所負責的任務之專一性；而"Coupling(耦合)"則是模組所負責的任務之間的相關性。

:::info
**Merging High cohesion ones.**
=> 比起兩個模組皆負責印出，不如一個模組負責印出。

**Separating Low coupling ones.**
=> 比起一個模組負責存入、排序和印出，不如三個模組分別負責存入、排序、印出。
:::

而所謂"Function abstraction"，則是將模組的目的與實作(implement)內容分開，也就是「模組的==具體運作方式並不重要，使用者只需了解怎麼使用，以及會發生什麼==即可」。

藉此哪怕你對於其他模組毫無了解，也能好好維護自己的模組且不影響其他模組的運作；反之哪怕別人對於你的模組毫無了解，也能正常使用你的模組(當然，前提是你有寫好)。

**A: 藉由將各模組獨立，即其他模組不須擔心某模組的實作，進而在進行維護、修改某模組時，縮減需檢查錯誤的範圍。**

---

###  **1-3 例題(Examples)**
#### Ex1 Grocery list
今天，你想要製作一張貨物清單，且其中除了頭尾兩項都有先行者(predecessor)及後繼者(successor)。

那我們可以先製作一張Operation contract(約等於說明文件)如下:
```cpp
// Operation contract of ADT list
// Contract only need input, behaviers, output.
//          NO actual codes needed.
class list {
    
// public:
    createList()            // 創建清單
    destroyList()           // 刪除清單
    isEmpty():boolean       // 檢查清單是否為空
    getLength():integer     // 計算清單長度
    
    insert( in index:integer, in newItem:listItemType, out success:boolean ) 
    // 在第index項插入一個新物品，使後面的所有物品被往後推一項。
    // 輸出一個bool，以確認是否有成功插入。

    remove( in index:integer, out success:boolean ) 
    // 移除第index項的物品，並使原本在下一項的物品前進一項。
    // 輸出一個bool，以確認是否有成功移除。

    retrieve( in index:integer, out dataItem:listItemType, out success:boolean ) 
    // 檢索第index項的物品。
    // 輸出listItemType dataItem，即第index項的內容。
    // 以及一個bool，以確認是否有成功檢索。
} // class aList
```

而依照上述描述，你可以輕鬆增加以下方法:
```cpp
    displayList()( aList:list ) {
    // 印出整個清單
        for( position = 1 to list.getLength() ) {
            aList.retrieve( position, dataItem, success ) ;
            Print dataItem ;
        } // end of for
        
    } // displayList()

    reverseList1( in aList:list, out success:boolean ) {
    // 將整個清單反過來，藉由把前面丟到後面。
        for( position = 0 to aList.getLength()-2 ) {
            aList.retrieve( position, dataItem, success ) ;
            aList.remove( position ) ;
            aList.insert( aList.getLength() + 1 - position, dataItem, success ) ;
        } // end of for
        
    } // reverseList1()

    reverseList2( in aList:list, out success:boolean ) {
    // 將整個清單反過來，藉由把後面丟到前面。
        for( position = 0 to aList.getLength()-2 ) {
            aList.retrieve( aList.getLength(), dataItem, success ) ;
            aList.insert( position, dataItem, success ) ;
            aList.remove( aList.getLength() ) ;
        } // end of for
        
    } // reverseList2()
```
而若想將該類別改成會自動依值排序的話:
```cpp
// Operation contract of ADT sortedList
class sortedList {
    
// public:
    createList()            // 創建清單
    destroyList()           // 刪除清單
    isEmpty():boolean       // 檢查清單是否為空
    getLength():integer     // 計算清單長度
    
    insert( in newItem:listItemType, out success:boolean ) 
    // 插入一個新物品，並依值重新排序。
    // 輸出一個bool，以確認是否有成功插入。

    remove( in index:integer, out success:boolean ) 
    // 移除第index項的物品。
    // 輸出一個bool，以確認是否有成功移除。

    retrieve( in index:integer, out dataItem:listItemType, out success:boolean ) 
    // 檢索第index項的物品。
    // 輸出listItemType dataItem，即第index項的內容。
    // 以及一個bool，以確認是否有成功檢索。
    
    locateItem( in value:integer, in newItem:listItemType, out success:boolean ): integer
    // 尋找newItem在清單中的index。
    // 輸出一個代表其index的整數。
    // 以及一個bool，以確認是否有成功檢索。
} // class aList
```

---

#### Ex2 Appointment book
今天，你想要製作一本行事曆，紀錄日期、時間、目的，且其中不應該有時間衝突的行程。

那此程式之架構可能如下:
```cpp
// Operation contract of ADT appointmentBook
class appointmentBook {    
    
// public:
    createAppointmentBook()     // 創建行事曆
    destroyAppointmentBook()    // 刪除行事曆
    
    addAppointment( in apptDate:Date, in apptTime:Time, in purpose:string ):boolean
    // 檢查是否有衝突，而後新增行程。
    // 輸出一個bool，以確認是否有成功新增。
    
    cancelAppointment( in apptDate:Date, in apptTime:Time ):boolean
    // 取消指定行程
    // 輸出一個bool，以確認是否有成功取消。
    
    isAppointment( in apptDate:Date, in apptTime:Time ):boolean
    // 檢查指定日期、時間是否已有行程。
    // 輸出一個bool，以表示檢查結果。

    checkAppointment( in apptDate:Date, in apptTime:Time, out purpose:string ) 
    // 檢索指定日期、時間的行程。
    // 輸出該行程的目的string。
} // class aList
```

而依照上述描述，你可以輕鬆增加以下程式:
```cpp
    moveAppointment( in oldDate:Date, in oldTime:Time, in newDate:Date, in newTime:Time ){
    // 將舊日期、時間的行程改到新日期、時間。
    // 並印出與結果相應的訊息。
        checkAppointment( oldDate, oldTime, purpose )
        if( purpose not NULL ) {
            if( addAppointment( newDate, newTime, purpose ) ) {
                print( "The appointment has been moved to " newTime " on " newDate ) ;
            } // end of if
            
            else print( "There is already an appointment at " newTime " on " newDate ) ;
            
        } // end of if
        
        else print( "There is no appointment at " oldTime " on " oldDate ) ;
    } // changeAppointment()

    changeAppointmentPurpose( in apptDate:Date, in apptTime:Time, in purpose:string ):boolean {
    // 將指定日期、時間的行程之目的改成新目的。
    // 輸出一個bool，以表示結果。
        if( isAppointment( apptDate, apptTime ) ) {
            cancelAppointment( apptDate, apptTime ) ;
        } // end of if
        
        return addAppointment( apptDate, apptTime, purpose ) ;
    } // changePurpose()

    displayAppointment( in apptDate:Date, in apptTime:Time ) {
    // 印出指定日期、時間的行程之日期、時間、目的。
        print( apptTime " on " apptDate " => " purpose ".\n" ) ;
    } // displayAppointment()

    displayAllAppointment( in apptDate:Date ) {
    // 印出指定日期從頭到尾的所有行程之日期、時間、目的。
        for( time = startOfDay ; time < endOfDay ; time = time + unithour ) {
            if( isAppointment( apptDate, time ) ) {
                displayAppointment( apptDate, time ) ;
            } // end of if
        
        } // end of while
    
    } // displayAllAppointment()
```

---

:arrow_right: 於上述兩個例題，我們在ADT說明文件中僅描述了程式的方法名稱、輸入、輸出，這樣做的好處是==不論具體怎麼是實作的，任何人都能夠輕鬆利用==。


## :memo: **Part2 抽象化資料型態之實作(Implement of abstracted datatype)**

###  **2-1 類別封裝(Types encapsulation)**
所謂封裝，就是==將特定資料成員隱藏在類別之中==，讓==使用者沒辦法從類別外部對前述資料成員進行存取==，僅能透過所提供的方法(setter、getter etc.)操作。
```cpp=0
/**@file Sphere.h*/
// above is the Header file
const double PI = 3.14159 ;

class Sphere {
    // constructors, can have multiple sets of arguments for multiple situations. 
    public Sphere() ; 
    // default, no initial condition
    
    public Sphere( double initialRadius ) {
    // with initial condition and what to do when initializing.
        if( initialRadius > 0 ) {
            radius = initialRadius ;
        } // end of if 
        
        else radius = 1.0 ;
    } // Shpere( double )
    
// ------------------------------------------

    // User can only set data members through availible setters.
    public void setRadius( double newRadius ) ;
    
    // User can only get data members through availible getters.
    public double getRadius() ;
    public double getDiameter() ;
    public double getCircumference() ;
    public double getArea() ;
    public double getVolume() ;
    void displayStatistics() ; // display all data members.
    
// ------------------------------------------

    // Data members are NOT directly accessible.
    private double radius ;
    private double diameter ;
    private double circumference ;
    private double area ;
    private double volume ;
} // class Sphere
```
實用例:

```cpp=0
#include <iostream>
#include "Sphere.h" // including header file.

using namespace stb ;

int main() {
    Sphere unitSphere ; // default constructor
    Sphere mySphere( 5.1 ) ; // constructor with initial condition.
    cout << mySphere.getDiameter() << endl ;
} // main()

```

---

###  **2-2 類別繼承(Types inheritance)**
在寫新的類別時，==若新類別屬於(IS-A)一種舊類別==，則為何不繼承舊類別的內容呢？
```cpp=0
#include "Sphere.h"
enum Color {RED, BLUE, GREEN, YELLOW, PURPLE}

// Because ColoredSphere IS-A Sphere.
// Thus ColoredSphere can inheriting from Sphere.
class ColoredSphere: public Sphere {
    // class ColoredSphere will have all data members and methods of Sphere.
    // And can adding new ones.
    
    // adding a new getter.
    public Color getColor() ;
    
    // adding a new data member.
    private Color color ;
} // class ColoredSphere
```

:::info
要注意的是關於繼承關係的兩方，其名稱有以下數種可能性:
- 繼承源:
父類別(Parent class)、主類別(Superclass)、基底類別(Base class)
- 繼承者:
子類別(Child class)、副類別(Subclass)、衍生類別(Derived class)
:::

---

###  **2-3 類別多載和覆載(Types overloading & overriding)**
而在寫程式時，你可能會覺得目前的==方法不夠，但新的方法又與既存的太過相似==，這時，多載(overload)就可以派上用場了。

:arrow_right: ==讓多個類似的方法共用同一個方法名稱，以參數(parameters)區別==。
```cpp=0
class Sphere {
    public Sphere() ; 
    public Sphere( double initialRadius ) {
        if( initialRadius > 0 ) {
            radius = initialRadius ;
        } // end of if 
    } // Shpere( double )
        
    public Sphere( double initialRadius, double initialDiameter ) {
    // new constructor, overloaded with different parameters
        if( initialRadius > 0 ) {
            radius = initialRadius ;
        } // end of if 
        if( initialDiameter > 0 ) {
            diameter = initialDiameter ;
        } // end of if 
    } // Shpere( double, double )
    
    // codes......
} // class Sphere
```
然後你也有可能覺得==原有的方法不夠適合繼承後的新類別==，這時，覆載(override)就可以派上用場了。

:arrow_right: ==將既有方法的實作內容改寫，但方法名稱及參數不變==。
```cpp=0
class Sphere {
    //codes......
    
    public Sphere( double initialRadius ) {
        if( initialRadius > 0 ) {
            radius = initialRadius ;
        } // end of if 
    } // Sphere()
    
    // codes......
} // class Sphere

class ColoredSphere: public Sphere {
    // codes......
    
    public ColoredSphere( double initialRadius ) {
        if( initialRadius > 0 ) {
            radius = initialRadius ;
        } // end of if 
        color = BLUE ; // new line by overriding this constructor.
    } // ColoredSphere()
    
    // codes......
} // class ColoredSphere
```

:::info
- 參數(Parameter): 宣告方法時所定義的變數。
- 引數(Argument): 呼叫方法時具體傳入的變數。
:::




## :memo: **Part3 C++ 類別 (C++ datatypes)**

###  **3-1 ADT序列(Array-based ADT)**
讓我們看回Ex1 Grocery list的程式架構並實作一部分:
```cpp
/**@file List.h*/

class list {
    // codes......
    
    public void insert( int index, listItemType newItem, bool success ) {
        if( index > 0 && index < size ) {
            for( int position = size - 1 ; position <= index ; position-- ) {
                items[index + 1] = items[index] ;
                // move all items after items[index] and itself 1 backward.
            } // end of for
            
            items[index] = newItem ; // add new item into items[index]
            size++ ; // size expanded.
            success = true ;
        } // end of if
        
        else success = false ;
    } // insert()
    
    public void remove( int index, bool success ) {
        if( index > 0 && index < size ) {
            for( int position = index +　１ ; position < size ; position++ ) {
                items[index - 1] = items[index] ;
                // move all items after items[index] 1 forward.
            } // end of for
            
            size-- ; // ignore item[last] since it's duplicated with items[last - 1].
            success = true ;
        } // end of if
        
        else success = false ;
    } // remove()
    
    public void retrieve( int index, listItemType dataItem, bool success ) {
        if( index > 0 && index < size ) {
            dataItem = items[index] ;
            success = true ;
        } // end of if
        
        else success = false ;
    } // retrieve()
    
    private int size ;
    private listItemType items[] ;
    
} // class list
    
void reverseList1( list aList, bool success ) {
// reverse the whole list 
// by moving all items from front to back.
    for( position = 0 to aList.getLength()-2 ) {
        aList.retrieve( position, dataItem, success ) ;
        aList.remove( position ) ;
        aList.insert( aList.getLength() + 1 - position, dataItem, success ) ;
    } // end of for
        
} // reverseList1()

void reverseList2( list aList, bool success ) {
// reverse the whole list 
// by moving all items from back to front.
    for( position = 0 to aList.getLength()-2 ) {
        aList.retrieve( aList.getLength(), dataItem, success ) ;
        aList.insert( position, dataItem, success ) ;
        aList.remove( aList.getLength() ) ;
    } // end of for
        
} // reverseList2()

void reverseList3( list aList, bool success ) {
// reverse the whole list 
// by moving all items from back to front.
    for( position = 0 to aList.getLength()-2 ) {
        aList.retrieve( aList.getLength(), dataItem, success ) ;
        aList.remove( aList.getLength() ) ;
        aList.insert( position, dataItem, success ) ;
    } // end of for
        
} // reverseList3()
```
在上述程式中，若我們想要測試reverseList()的效率，則先假設aList.size為一個不大的數字:

| aList.size = 5  | reverseList1() | reverseList2() | reverseList3() |
| --------------- | :------------: | :------------: | :------------: |
|   物品位移次數    |       22       |       14       |       10       |
|   insert()詳細   |  0+1+2+3 = 6   |  5+4+3+2 = 14  |  4+3+2+1 = 10  |
|   remove()詳細   |  4+4+4+4 = 16  |  0+0+0+0 = 0   |  0+0+0+0 = 0   |

既然aList.size = 5最多就差了12次，那aList.size = 50又是如何?
| aList.size = 50 |   reverseList1()  |    reverseList2()   |    reverseList3()   |
| --------------- | :---------------: | :-----------------: | :-----------------: |
|   物品位移次數    |        3577       |         1224        |         1176        |
|   insert()詳細   | 0+1+...+48 = 1176 | 49+48+....+2 = 1224 | 48+47+....+1 = 1176 |
|   remove()詳細   |   49 * 49 = 2401  |     0 * 49 = 0      |     0 * 49 = 0      |

由此可見，在aList.size很大的時候，reverseList2()明顯更有效率，且reverseList3()又更加有效率。

---

###  **3-2 ADT多項式(ADT polynomial)**
基本上在寫程式時，你大多數時候都會需要進行所謂的"堆積木"，也就是==將既存的函數互相組合以達成目的==。
```cpp=0
#include "List.h"
// given listItemType is integer.

// We have......
class polynomial {
    private list cofficients ;
    // we'll store the coefficient of x^N at items[N].
    
    public int degree() {
    // get the highest power of the polynomial.
        return getLength() - 1 ;
    } // degree()
    
    public int getCoeff( int power ) {
    // get the coefficient of x^power.
        int result ;
        bool success ;
        cofficients.retrieve( power, result, success ) ;
        
        if( success ) {
            return result ;
        } // end of if
        else return 0 ;
        
    } // getCoeff()
    
    public void changeCoeff( int newCoeff, int power ) {
    // change the coefficient of x^power.
        bool success ;
        cofficients.remove( power, success ) ;
        
        if( success ) {
            cofficients.insert( newCoeff, power, success ) ;
        } // end of if
        
    } // changeCoeff()

    
    // codes......
} // class polynomial

// -------------------------------------
// We want to......
// 1. Display the highest power of the polynomial.
// 2. Increase the coefficient of x^2 by 7.
// 3. Compute the sum of two polynomials.
// then......

polynomial p1 ;
polynomial p2 ;
polynomial result ;

// 1. 
display( p1.degree() ) ;

// 2.
p1.changeCoeff( p1.getCoeff( power ) + increament, power ) ;

// 3. 
for( int idx = 0 ; idx < p1.degree() || idx < p2.degree() ; idx++ ) {
    result.changeCoeff( p1.getCoeff( idx ) + p2.getCoeff( idx ), idx )
}
```

---

###  **3-3 命名空間(Namespaces)**
在寫程式時，你可能曾經有過類似「真不想每一次都重複寫那個函數啊。」的想法，這時命名空間就很有用了。

你可以將所有常用的函數、宣告等全部放在命名空間之中，之後只要經由該空間即可使用。

```cpp
// something like this......
namespace aSpace {
    int aInt ;
    
    void aMethod() ;
} // namespace aSpace
```
你還記得「using namespace std ;」吧？有時也會在網路上看見如std::find()之類的句子。

1. 只要利用「==::==」寫下「aSpace::function/declaration」之類的， 就可以限定使用該命名空間的一部份。
2. 又或是在程式開頭寫下「==using== namespace aSpace ;」，藉此直接使用整個命名空間。

```cpp
// first way
aSpace::aInt = 4 ;
aSpace::aMethod() ;

// second way
using namespace aSpace ;
aInt = 4 ;
aMethod() ;
```

---

###  **3-4 例外處理(Exceptions handling)**
在寫程式時，你還有可能遇到例外狀況，在C++中，例外狀況也可被視為一種物件。
```cpp
// put this at where seems break easily.
try{ throw( type ) ; }

// codes......

// all catch blocks corresponding to try
catch( type1 ) { statement1 }
catch( type2 ) { statement2 }
catch( type3 ) { statement3 }
catch( ..... ) { .......... }
```
實作例子：　
```cpp=0
#include <stdexcept>
#include <string>
using namespace std ;

class ListIndexOutOfRangeExceptation : public out_of_range {
    public ListIndexOutOfRangeExceptation( const string &message = "" )
                         : out_of_range( message.e_str() ) 
    { }
} // class ListIndexOutOfRangeExceptation

class ListLogicErrorExceptation : public logic_error {
    public ListLogicErrorExceptation( const string &message = "" )
                         : logic_error( message.c_str() ) 
    { }
} // class ListLogicErrorExceptation

// --------------
void list.h::insert( int index, listItemType newitem ) 
throw( ListIndexOutOfRangeExceptation, ListLogicErrorExceptation ) 
{
    // the "throw()" above is used to control
    //     the exceptations this function may throw.
    // and it allows easier error targeting.
    
    // codes......
    
    if( size > MAX_LIST ) {
        throw ListLogicErrorExceptation( "ListLogicErrorExceptation: " 
                                       + "List full on insert." ) ;
    } // end of if
    
    // codes......
} // list.h::insert()
```




## :memo: **Part4 結論(Summary)**
:::success
1. 藉由資料抽象化控制在程式與其資料結構之間的互動。
2. 應在設計、實作程式之前就先定義好ADT。
3. 藉由ADT來將實作方法從使用者眼中隱藏起來。
4. 可利用header file幫助實作類別。
:::